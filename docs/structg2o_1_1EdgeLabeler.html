<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>g2o: g2o::EdgeLabeler Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">g2o
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceg2o.html">g2o</a></li><li class="navelem"><a class="el" href="structg2o_1_1EdgeLabeler.html">EdgeLabeler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="structg2o_1_1EdgeLabeler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">g2o::EdgeLabeler Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="edge__labeler_8h_source.html">edge_labeler.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for g2o::EdgeLabeler:</div>
<div class="dyncontent">
<div class="center"><img src="structg2o_1_1EdgeLabeler__coll__graph.png" border="0" usemap="#g2o_1_1EdgeLabeler_coll__map" alt="Collaboration graph"/></div>
<map name="g2o_1_1EdgeLabeler_coll__map" id="g2o_1_1EdgeLabeler_coll__map">
<area shape="rect" id="node2" href="classg2o_1_1SparseOptimizer.html" title="g2o::SparseOptimizer" alt="" coords="201,261,349,288"/>
<area shape="rect" id="node8" href="classg2o_1_1OptimizationAlgorithm.html" title="Generic interface for a non&#45;linear solver operating on a graph. " alt="" coords="89,351,268,377"/>
<area shape="rect" id="node3" href="structg2o_1_1OptimizableGraph.html" title="g2o::OptimizableGraph" alt="" coords="197,178,352,205"/>
<area shape="rect" id="node4" href="classg2o_1_1HyperGraph.html" title="g2o::HyperGraph" alt="" coords="45,81,166,108"/>
<area shape="rect" id="node5" href="classg2o_1_1JacobianWorkspace.html" title="provide memory workspace for computing the Jacobians " alt="" coords="190,81,359,108"/>
<area shape="rect" id="node6" href="classg2o_1_1ParameterContainer.html" title="map id to parameters " alt="" coords="383,81,550,108"/>
<area shape="rect" id="node9" href="classg2o_1_1PropertyMap.html" title="a collection of properties mapping from name to the property itself " alt="" coords="16,261,141,288"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeef6a564c390bb635cf42da1e1669c5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg2o_1_1EdgeLabeler.html#aeef6a564c390bb635cf42da1e1669c5b">EdgeLabeler</a> (<a class="el" href="classg2o_1_1SparseOptimizer.html">SparseOptimizer</a> *optimizer)</td></tr>
<tr class="separator:aeef6a564c390bb635cf42da1e1669c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74d25d0bbca21d8660ae2d3bacf89da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg2o_1_1EdgeLabeler.html#ad74d25d0bbca21d8660ae2d3bacf89da">labelEdges</a> (std::set&lt; <a class="el" href="classg2o_1_1OptimizableGraph_1_1Edge.html">OptimizableGraph::Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="separator:ad74d25d0bbca21d8660ae2d3bacf89da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0bc4741ade25cceeed661d8a5dacce65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg2o_1_1EdgeLabeler.html#a0bc4741ade25cceeed661d8a5dacce65">augmentSparsePattern</a> (std::set&lt; std::pair&lt; int, int &gt; &gt; &amp;pattern, <a class="el" href="classg2o_1_1OptimizableGraph_1_1Edge.html">OptimizableGraph::Edge</a> *e)</td></tr>
<tr class="separator:a0bc4741ade25cceeed661d8a5dacce65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbc70c30c6f3739758ad739534c0e0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg2o_1_1EdgeLabeler.html#a7dbc70c30c6f3739758ad739534c0e0c">computePartialInverse</a> (<a class="el" href="classg2o_1_1SparseBlockMatrix.html">SparseBlockMatrix</a>&lt; Eigen::MatrixXd &gt; &amp;spinv, const std::set&lt; std::pair&lt; int, int &gt; &gt; &amp;pattern)</td></tr>
<tr class="separator:a7dbc70c30c6f3739758ad739534c0e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c98ef2547a8f7345bf8b3eab61f38c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg2o_1_1EdgeLabeler.html#a8c98ef2547a8f7345bf8b3eab61f38c2">labelEdge</a> (const <a class="el" href="classg2o_1_1SparseBlockMatrix.html">SparseBlockMatrix</a>&lt; Eigen::MatrixXd &gt; &amp;spinv, <a class="el" href="classg2o_1_1OptimizableGraph_1_1Edge.html">OptimizableGraph::Edge</a> *e)</td></tr>
<tr class="separator:a8c98ef2547a8f7345bf8b3eab61f38c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:affba25d694474e9c4b1b4c628fdd8dcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classg2o_1_1SparseOptimizer.html">SparseOptimizer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg2o_1_1EdgeLabeler.html#affba25d694474e9c4b1b4c628fdd8dcc">_optimizer</a></td></tr>
<tr class="separator:affba25d694474e9c4b1b4c628fdd8dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements the functions to label an edge (measurement) based on the actual configuration of the nodes. It does so by </p><ul>
<li>
computing the expected mean of the measurement (_measurement) based on the state variables </li>
<li>
computing the joint covariance matrix of all sstate variables on which the measurement depends. </li>
<li>
extracting the sigma points from this covariance matrix (which is in the space if the increments used by  </li>
<li>
projecting the sigma points in the error space, and thus computing the information matrix of the labeled edge </li>
</ul>

<p>Definition at line <a class="el" href="edge__labeler_8h_source.html#l00020">20</a> of file <a class="el" href="edge__labeler_8h_source.html">edge_labeler.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeef6a564c390bb635cf42da1e1669c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">g2o::EdgeLabeler::EdgeLabeler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classg2o_1_1SparseOptimizer.html">SparseOptimizer</a> *&#160;</td>
          <td class="paramname"><em>optimizer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>constructs an edge labeler that operates on the optimizer passed as argument </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optimizer</td><td>the optimizer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="edge__labeler_8cpp_source.html#l00012">12</a> of file <a class="el" href="edge__labeler_8cpp_source.html">edge_labeler.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;                                                     {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <a class="code" href="structg2o_1_1EdgeLabeler.html#affba25d694474e9c4b1b4c628fdd8dcc">_optimizer</a> = optimizer;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  }</div><div class="ttc" id="structg2o_1_1EdgeLabeler_html_affba25d694474e9c4b1b4c628fdd8dcc"><div class="ttname"><a href="structg2o_1_1EdgeLabeler.html#affba25d694474e9c4b1b4c628fdd8dcc">g2o::EdgeLabeler::_optimizer</a></div><div class="ttdeci">SparseOptimizer * _optimizer</div><div class="ttdef"><b>Definition:</b> <a href="edge__labeler_8h_source.html#l00047">edge_labeler.h:47</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0bc4741ade25cceeed661d8a5dacce65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void g2o::EdgeLabeler::augmentSparsePattern </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classg2o_1_1OptimizableGraph_1_1Edge.html">OptimizableGraph::Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>helper function that augments the sparse pattern of the inverse based on an edge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>the blocks of the inverse covered by the edge </td></tr>
    <tr><td class="paramname">e</td><td>the edge </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="edge__labeler_8cpp_source.html#l00041">41</a> of file <a class="el" href="edge__labeler_8cpp_source.html">edge_labeler.cpp</a>.</p>

<p>References <a class="el" href="optimizable__graph_8h_source.html#l00266">g2o::OptimizableGraph::Vertex::hessianIndex()</a>, and <a class="el" href="hyper__graph_8h_source.html#l00178">g2o::HyperGraph::Edge::vertices()</a>.</p>
<div class="fragment"><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                                                                                                    {</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;e-&gt;vertices().size(); i++){</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;      <span class="keyword">const</span> <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>* v=(<span class="keyword">const</span> <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>*) e-&gt;vertices()[i];</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;      <span class="keywordtype">int</span> ti=v-&gt;hessianIndex();</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;      <span class="keywordflow">if</span> (ti==-1)</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=i; j&lt;e-&gt;vertices().size(); j++){</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="keyword">const</span> <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>* v=(<span class="keyword">const</span> <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>*) e-&gt;vertices()[j];</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordtype">int</span> tj = v-&gt;hessianIndex();</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordflow">if</span> (tj==-1)</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <span class="keywordflow">if</span>(tj&lt;ti)</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;          swap(ti,tj);</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        pattern.insert(std::make_pair(ti, tj));</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;      }</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    }</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  }</div><div class="ttc" id="structg2o_1_1OptimizableGraph_html_ae1bdcfc2f7a1b8977ba04a16b16f1eba"><div class="ttname"><a href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">g2o::OptimizableGraph::Vertex</a></div><div class="ttdeci">class G2O_CORE_API Vertex</div><div class="ttdef"><b>Definition:</b> <a href="optimizable__graph_8h_source.html#l00075">optimizable_graph.h:75</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7dbc70c30c6f3739758ad739534c0e0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool g2o::EdgeLabeler::computePartialInverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classg2o_1_1SparseBlockMatrix.html">SparseBlockMatrix</a>&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>spinv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>helper function that computes the inverse based on the sparse pattenrn </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spinv</td><td>the output block inverse </td></tr>
    <tr><td class="paramname">pattern</td><td>the blocks of the inverse covered by the edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successm, false on failure, . </dd></dl>

<p>Definition at line <a class="el" href="edge__labeler_8cpp_source.html#l00059">59</a> of file <a class="el" href="edge__labeler_8cpp_source.html">edge_labeler.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                                                                                                                     {</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    std::vector&lt;std::pair&lt;int, int&gt; &gt; blockIndices(pattern.size());</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="comment">// Why this does not work???</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="comment">//std::copy(pattern.begin(),pattern.end(),blockIndices.begin());</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordtype">int</span> k=0;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">for</span>(std::set&lt;std::pair&lt;int, int&gt; &gt;::const_iterator it= pattern.begin(); it!=pattern.end(); it++){</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      blockIndices[k++]=*it;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    }</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="comment">//cerr &lt;&lt; &quot;sparse pattern contains &quot; &lt;&lt; blockIndices.size() &lt;&lt; &quot; blocks&quot; &lt;&lt; endl;</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structg2o_1_1EdgeLabeler.html#affba25d694474e9c4b1b4c628fdd8dcc">_optimizer</a>-&gt;<a class="code" href="classg2o_1_1SparseOptimizer.html#a84f392391a596d740c24d75af3554b13">computeMarginals</a>(spinv, blockIndices);</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  }</div><div class="ttc" id="structg2o_1_1EdgeLabeler_html_affba25d694474e9c4b1b4c628fdd8dcc"><div class="ttname"><a href="structg2o_1_1EdgeLabeler.html#affba25d694474e9c4b1b4c628fdd8dcc">g2o::EdgeLabeler::_optimizer</a></div><div class="ttdeci">SparseOptimizer * _optimizer</div><div class="ttdef"><b>Definition:</b> <a href="edge__labeler_8h_source.html#l00047">edge_labeler.h:47</a></div></div>
<div class="ttc" id="classg2o_1_1SparseOptimizer_html_a84f392391a596d740c24d75af3554b13"><div class="ttname"><a href="classg2o_1_1SparseOptimizer.html#a84f392391a596d740c24d75af3554b13">g2o::SparseOptimizer::computeMarginals</a></div><div class="ttdeci">bool computeMarginals(SparseBlockMatrix&lt; MatrixXD &gt; &amp;spinv, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;blockIndices)</div><div class="ttdef"><b>Definition:</b> <a href="sparse__optimizer_8cpp_source.html#l00579">sparse_optimizer.cpp:579</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8c98ef2547a8f7345bf8b3eab61f38c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool g2o::EdgeLabeler::labelEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classg2o_1_1SparseBlockMatrix.html">SparseBlockMatrix</a>&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>spinv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classg2o_1_1OptimizableGraph_1_1Edge.html">OptimizableGraph::Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>helper function that labes a specific edge based on the marginals in the sparse block inverse </p><dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

<p>Definition at line <a class="el" href="edge__labeler_8cpp_source.html#l00073">73</a> of file <a class="el" href="edge__labeler_8cpp_source.html">edge_labeler.cpp</a>.</p>

<p>References <a class="el" href="sparse__block__matrix_8hpp_source.html#l00091">g2o::SparseBlockMatrix&lt; MatrixType &gt;::block()</a>, <a class="el" href="classg2o_1_1OptimizableGraph_1_1Edge.html#a1e6d9f4128866982de5e11e03edd7775">g2o::OptimizableGraph::Edge::computeError()</a>, <a class="el" href="optimizable__graph_8h_source.html#l00440">g2o::OptimizableGraph::Edge::dimension()</a>, <a class="el" href="classg2o_1_1OptimizableGraph_1_1Edge.html#a5f2a4b6efa2d0ae600f94a28a6ba58cf">g2o::OptimizableGraph::Edge::errorData()</a>, <a class="el" href="optimizable__graph_8h_source.html#l00266">g2o::OptimizableGraph::Vertex::hessianIndex()</a>, <a class="el" href="classg2o_1_1OptimizableGraph_1_1Edge.html#ab5b315b3e0a6c4e29074b2c924460417">g2o::OptimizableGraph::Edge::informationData()</a>, <a class="el" href="optimizable__graph_8cpp_source.html#l00114">g2o::OptimizableGraph::Vertex::minimalEstimateDimension()</a>, <a class="el" href="optimizable__graph_8h_source.html#l00259">g2o::OptimizableGraph::Vertex::oplus()</a>, <a class="el" href="classg2o_1_1OptimizableGraph_1_1Vertex.html#a3e36d925dbda1c574a285826ade5909a">g2o::OptimizableGraph::Vertex::pop()</a>, <a class="el" href="classg2o_1_1OptimizableGraph_1_1Vertex.html#aa477ed33d30a01ed468f33bb2a2f2d9d">g2o::OptimizableGraph::Vertex::push()</a>, <a class="el" href="unscented_8h_source.html#l00078">g2o::reconstructGaussian()</a>, <a class="el" href="unscented_8h_source.html#l00049">g2o::sampleUnscented()</a>, <a class="el" href="optimizable__graph_8cpp_source.html#l00207">g2o::OptimizableGraph::Edge::setMeasurementFromState()</a>, and <a class="el" href="hyper__graph_8h_source.html#l00178">g2o::HyperGraph::Edge::vertices()</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                                                                                               {</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    Eigen::Map&lt;MatrixXd&gt; info(e-&gt;informationData(), e-&gt;dimension(), e-&gt;dimension());</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="comment">// cerr &lt;&lt; &quot;original information matrix&quot; &lt;&lt; endl;</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="comment">// cerr &lt;&lt; info &lt;&lt; endl;</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordtype">int</span> maxDim=0;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;e-&gt;vertices().size(); i++){</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      <span class="keyword">const</span> <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>* v=(<span class="keyword">const</span> <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>*) e-&gt;vertices()[i];</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;      <span class="keywordtype">int</span> ti=v-&gt;hessianIndex();</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;      <span class="keywordflow">if</span> (ti==-1)</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;      maxDim+=v-&gt;minimalEstimateDimension();</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    }</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="comment">//cerr &lt;&lt; &quot;maxDim= &quot; &lt;&lt; maxDim &lt;&lt; endl;</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    MatrixXd cov(maxDim, maxDim);</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordtype">int</span> cumRow=0;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;e-&gt;vertices().size(); i++){</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      <span class="keyword">const</span> <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>* vr=(<span class="keyword">const</span> <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>*) e-&gt;vertices()[i];</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      <span class="keywordtype">int</span> ti=vr-&gt;hessianIndex();</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      <span class="keywordflow">if</span> (ti&gt;-1) {</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        <span class="keywordtype">int</span> cumCol=0;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;e-&gt;vertices().size(); j++){</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;          <span class="keyword">const</span> <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>* vc=(<span class="keyword">const</span> <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>*) e-&gt;vertices()[j];</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;          <span class="keywordtype">int</span> tj = vc-&gt;hessianIndex();</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;          <span class="keywordflow">if</span> (tj&gt;-1){</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            <span class="comment">// cerr &lt;&lt; &quot;ti=&quot; &lt;&lt; ti &lt;&lt; &quot; tj=&quot; &lt;&lt; tj</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;            <span class="comment">//    &lt;&lt; &quot; cumRow=&quot; &lt;&lt; cumRow &lt;&lt; &quot; cumCol=&quot; &lt;&lt; cumCol &lt;&lt; endl;</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            <span class="keywordflow">if</span> (ti&lt;=tj){</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;              assert(spinv.<a class="code" href="classg2o_1_1SparseBlockMatrix.html#aaca7b38d2e9a18eebf9e6f5957af0cf7">block</a>(ti, tj));</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;              <span class="comment">// cerr &lt;&lt; &quot;cblock_ptr&quot; &lt;&lt; spinv.block(ti, tj) &lt;&lt; endl;</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;              <span class="comment">// cerr &lt;&lt; &quot;cblock.size=&quot; &lt;&lt; spinv.block(ti, tj)-&gt;rows() &lt;&lt; &quot;,&quot; &lt;&lt; spinv.block(ti, tj)-&gt;cols() &lt;&lt; endl;</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;              <span class="comment">// cerr &lt;&lt; &quot;cblock&quot; &lt;&lt; endl;</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;              <span class="comment">// cerr &lt;&lt; *spinv.block(ti, tj) &lt;&lt; endl;</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;              cov.block(cumRow, cumCol, vr-&gt;minimalEstimateDimension(), vc-&gt;minimalEstimateDimension()) =</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                *spinv.<a class="code" href="classg2o_1_1SparseBlockMatrix.html#aaca7b38d2e9a18eebf9e6f5957af0cf7">block</a>(ti, tj);</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;              assert(spinv.<a class="code" href="classg2o_1_1SparseBlockMatrix.html#aaca7b38d2e9a18eebf9e6f5957af0cf7">block</a>(tj, ti));</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;              <span class="comment">// cerr &lt;&lt; &quot;cblock.size=&quot; &lt;&lt; spinv.block(tj, ti)-&gt;cols() &lt;&lt; &quot;,&quot; &lt;&lt; spinv.block(tj, ti)-&gt;rows() &lt;&lt; endl;</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;              <span class="comment">// cerr &lt;&lt; &quot;cblock&quot; &lt;&lt; endl;</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;              <span class="comment">// cerr &lt;&lt; spinv.block(tj, ti)-&gt;transpose() &lt;&lt; endl;</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;              cov.block(cumRow, cumCol, vr-&gt;minimalEstimateDimension(), vc-&gt;minimalEstimateDimension()) =</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                spinv.<a class="code" href="classg2o_1_1SparseBlockMatrix.html#aaca7b38d2e9a18eebf9e6f5957af0cf7">block</a>(tj, ti)-&gt;transpose();</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            }</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            cumCol += vc-&gt;minimalEstimateDimension();</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;          }</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        }</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        cumRow += vr-&gt;minimalEstimateDimension();</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;      }</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="comment">// cerr &lt;&lt; &quot;covariance assembled&quot; &lt;&lt; endl;</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="comment">// cerr &lt;&lt; cov &lt;&lt; endl;</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="comment">// now cov contains the aggregate marginals of the state variables in the edge</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    VectorXd incMean(maxDim);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    incMean.fill(0);</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    std::vector&lt;MySigmaPoint, Eigen::aligned_allocator&lt;MySigmaPoint&gt; &gt; incrementPoints;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="keywordflow">if</span> (! <a class="code" href="namespaceg2o.html#af60b2532fdb5e5dd9b6cf11d01750fdc">sampleUnscented</a>(incrementPoints, incMean, cov)){</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;      cerr &lt;&lt; <span class="stringliteral">&quot;sampleUnscented fail&quot;</span> &lt;&lt; endl;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="comment">// now determine the zero-error measure by applying the error function of the edge</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="comment">// with a zero measurement</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="comment">// TODO!!!</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="keywordtype">bool</span> smss = e-&gt;setMeasurementFromState();</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keywordflow">if</span> (! smss) {</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;      cerr &lt;&lt; <span class="stringliteral">&quot;FATAL: Edge::setMeasurementFromState() not implemented&quot;</span> &lt;&lt; endl;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    }</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    assert(smss &amp;&amp; <span class="stringliteral">&quot;Edge::setMeasurementFromState() not implemented&quot;</span>);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="comment">//std::vector&lt;MySigmaPoint&gt; globalPoints(incrementPoints.size());</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    std::vector&lt;MySigmaPoint, Eigen::aligned_allocator&lt;MySigmaPoint&gt; &gt; errorPoints(incrementPoints.size());</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="comment">// for each sigma point, project it to the global space, by considering those variables</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="comment">// that are involved</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="comment">//cerr &lt;&lt; &quot;sigma points are extracted, remapping to measurement space&quot; &lt;&lt; endl;</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;incrementPoints.size(); i++) {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;      <span class="keywordtype">int</span> cumPos=0;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;      <span class="comment">//VectorXd globalPoint(maxDim);</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      <span class="comment">// push all the &quot;active&quot; state variables</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;e-&gt;vertices().size(); j++){</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>* vr=(<a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>*) e-&gt;vertices()[j];</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        <span class="keywordtype">int</span> tj=vr-&gt;hessianIndex();</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        <span class="keywordflow">if</span> (tj==-1)</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        vr-&gt;push();</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;      }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;e-&gt;vertices().size(); j++){</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>* vr=(<a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>*) e-&gt;vertices()[j];</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keywordtype">int</span> tj=vr-&gt;hessianIndex();</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keywordflow">if</span> (tj==-1)</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        vr-&gt;oplus(&amp;incrementPoints[i]._sample[cumPos]);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <span class="comment">//assert(vr-&gt;getMinimalEstimateData(&amp;globalPoint[cumPos]) &amp;&amp; &quot;Vertex::getMinimalEstimateData(...) not implemented&quot;);</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        cumPos+=vr-&gt;minimalEstimateDimension();</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;      }</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;      <span class="comment">// construct the sigma point in the global space</span></div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;      <span class="comment">// globalPoints[i]._sample=globalPoint;</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;      <span class="comment">// globalPoints[i]._wi=incrementPoints[i]._wi;</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;      <span class="comment">// globalPoints[i]._wp=incrementPoints[i]._wp;</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;      <span class="comment">// construct the sigma point in the error space</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;      e-&gt;computeError();</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;      Map&lt;VectorXd&gt; errorPoint(e-&gt;errorData(),e-&gt;dimension());</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;      errorPoints[i]._sample=errorPoint;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;      errorPoints[i]._wi=incrementPoints[i]._wi;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;      errorPoints[i]._wp=incrementPoints[i]._wp;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;      <span class="comment">// pop all the &quot;active&quot; state variables</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;e-&gt;vertices().size(); j++){</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        <a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>* vr=(<a class="code" href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">OptimizableGraph::Vertex</a>*) e-&gt;vertices()[j];</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="keywordtype">int</span> tj=vr-&gt;hessianIndex();</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        <span class="keywordflow">if</span> (tj==-1)</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        vr-&gt;pop();</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;      }</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    }</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="comment">// reconstruct the covariance of the error by the sigma points</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    MatrixXd errorCov(e-&gt;dimension(), e-&gt;dimension());</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    VectorXd errorMean(e-&gt;dimension());</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <a class="code" href="namespaceg2o.html#aa86e81b0532571ae8664473f8f88a6a8">reconstructGaussian</a>(errorMean, errorCov, errorPoints);</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    info=errorCov.inverse();</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="comment">// cerr &lt;&lt; &quot;remapped information matrix&quot; &lt;&lt; endl;</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="comment">// cerr &lt;&lt; info &lt;&lt; endl;</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;  }</div><div class="ttc" id="classg2o_1_1SparseBlockMatrix_html_aaca7b38d2e9a18eebf9e6f5957af0cf7"><div class="ttname"><a href="classg2o_1_1SparseBlockMatrix.html#aaca7b38d2e9a18eebf9e6f5957af0cf7">g2o::SparseBlockMatrix::block</a></div><div class="ttdeci">SparseMatrixBlock * block(int r, int c, bool alloc=false)</div><div class="ttdoc">returns the block at location r,c. if alloc=true he block is created if it does not exist ...</div><div class="ttdef"><b>Definition:</b> <a href="sparse__block__matrix_8hpp_source.html#l00091">sparse_block_matrix.hpp:91</a></div></div>
<div class="ttc" id="namespaceg2o_html_aa86e81b0532571ae8664473f8f88a6a8"><div class="ttname"><a href="namespaceg2o.html#aa86e81b0532571ae8664473f8f88a6a8">g2o::reconstructGaussian</a></div><div class="ttdeci">void reconstructGaussian(SampleType &amp;mean, CovarianceType &amp;covariance, const std::vector&lt; SigmaPoint&lt; SampleType &gt;, Eigen::aligned_allocator&lt; SigmaPoint&lt; SampleType &gt; &gt; &gt; &amp;sigmaPoints)</div><div class="ttdef"><b>Definition:</b> <a href="unscented_8h_source.html#l00078">unscented.h:78</a></div></div>
<div class="ttc" id="structg2o_1_1OptimizableGraph_html_ae1bdcfc2f7a1b8977ba04a16b16f1eba"><div class="ttname"><a href="structg2o_1_1OptimizableGraph.html#ae1bdcfc2f7a1b8977ba04a16b16f1eba">g2o::OptimizableGraph::Vertex</a></div><div class="ttdeci">class G2O_CORE_API Vertex</div><div class="ttdef"><b>Definition:</b> <a href="optimizable__graph_8h_source.html#l00075">optimizable_graph.h:75</a></div></div>
<div class="ttc" id="namespaceg2o_html_af60b2532fdb5e5dd9b6cf11d01750fdc"><div class="ttname"><a href="namespaceg2o.html#af60b2532fdb5e5dd9b6cf11d01750fdc">g2o::sampleUnscented</a></div><div class="ttdeci">bool sampleUnscented(std::vector&lt; SigmaPoint&lt; SampleType &gt;, Eigen::aligned_allocator&lt; SigmaPoint&lt; SampleType &gt; &gt; &gt; &amp;sigmaPoints, const SampleType &amp;mean, const CovarianceType &amp;covariance)</div><div class="ttdef"><b>Definition:</b> <a href="unscented_8h_source.html#l00049">unscented.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad74d25d0bbca21d8660ae2d3bacf89da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g2o::EdgeLabeler::labelEdges </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classg2o_1_1OptimizableGraph_1_1Edge.html">OptimizableGraph::Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Labels the set of edges passed as argument. It computes the cholesky information matrix. This method only woorks aftec having called an optimize(...) in the connected optimizer. The labeling is performed based on the actual configuration of the nodes in the optimized subgraph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>the edges to label </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the inverse cholesky cannot be computed, otherwise the number of edges where the labeling was successful </dd></dl>

<p>Definition at line <a class="el" href="edge__labeler_8cpp_source.html#l00016">16</a> of file <a class="el" href="edge__labeler_8cpp_source.html">edge_labeler.cpp</a>.</p>

<p>Referenced by <a class="el" href="star_8cpp_source.html#l00009">g2o::Star::labelStarEdges()</a>.</p>
<div class="fragment"><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;                                                                 {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <span class="comment">// assume the system is &quot;solved&quot;</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <span class="comment">// compute the sparse pattern of the inverse</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    std::set&lt;std::pair&lt;int, int&gt; &gt; pattern;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="keywordflow">for</span> (std::set&lt;OptimizableGraph::Edge*&gt;::iterator it=edges.begin(); it!=edges.end(); it++){</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;      <a class="code" href="structg2o_1_1EdgeLabeler.html#a0bc4741ade25cceeed661d8a5dacce65">augmentSparsePattern</a>(pattern, *it);</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    }</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    SparseBlockMatrix&lt;MatrixXd&gt; spInv;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <span class="keywordtype">bool</span> result = <a class="code" href="structg2o_1_1EdgeLabeler.html#a7dbc70c30c6f3739758ad739534c0e0c">computePartialInverse</a>(spInv, pattern);</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="comment">//cerr &lt;&lt; &quot;partial inverse computed = &quot; &lt;&lt; result &lt;&lt; endl;</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="comment">//cerr &lt;&lt; &quot;non zero blocks&quot; &lt;&lt; spInv.nonZeroBlocks() &lt;&lt; endl;</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <span class="keywordflow">if</span> (! result ){</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;      <span class="keywordflow">return</span> -1;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    }</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordtype">int</span> count=0;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="keywordflow">for</span> (std::set&lt;OptimizableGraph::Edge*&gt;::iterator it=edges.begin(); it!=edges.end(); it++){</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;      count += <a class="code" href="structg2o_1_1EdgeLabeler.html#a8c98ef2547a8f7345bf8b3eab61f38c2">labelEdge</a>(spInv, *it) ? 1 : 0;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    }</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="keywordflow">return</span> count;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  }</div><div class="ttc" id="structg2o_1_1EdgeLabeler_html_a0bc4741ade25cceeed661d8a5dacce65"><div class="ttname"><a href="structg2o_1_1EdgeLabeler.html#a0bc4741ade25cceeed661d8a5dacce65">g2o::EdgeLabeler::augmentSparsePattern</a></div><div class="ttdeci">void augmentSparsePattern(std::set&lt; std::pair&lt; int, int &gt; &gt; &amp;pattern, OptimizableGraph::Edge *e)</div><div class="ttdef"><b>Definition:</b> <a href="edge__labeler_8cpp_source.html#l00041">edge_labeler.cpp:41</a></div></div>
<div class="ttc" id="structg2o_1_1EdgeLabeler_html_a8c98ef2547a8f7345bf8b3eab61f38c2"><div class="ttname"><a href="structg2o_1_1EdgeLabeler.html#a8c98ef2547a8f7345bf8b3eab61f38c2">g2o::EdgeLabeler::labelEdge</a></div><div class="ttdeci">bool labelEdge(const SparseBlockMatrix&lt; Eigen::MatrixXd &gt; &amp;spinv, OptimizableGraph::Edge *e)</div><div class="ttdef"><b>Definition:</b> <a href="edge__labeler_8cpp_source.html#l00073">edge_labeler.cpp:73</a></div></div>
<div class="ttc" id="structg2o_1_1EdgeLabeler_html_a7dbc70c30c6f3739758ad739534c0e0c"><div class="ttname"><a href="structg2o_1_1EdgeLabeler.html#a7dbc70c30c6f3739758ad739534c0e0c">g2o::EdgeLabeler::computePartialInverse</a></div><div class="ttdeci">bool computePartialInverse(SparseBlockMatrix&lt; Eigen::MatrixXd &gt; &amp;spinv, const std::set&lt; std::pair&lt; int, int &gt; &gt; &amp;pattern)</div><div class="ttdef"><b>Definition:</b> <a href="edge__labeler_8cpp_source.html#l00059">edge_labeler.cpp:59</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="affba25d694474e9c4b1b4c628fdd8dcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classg2o_1_1SparseOptimizer.html">SparseOptimizer</a>* g2o::EdgeLabeler::_optimizer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="edge__labeler_8h_source.html#l00047">47</a> of file <a class="el" href="edge__labeler_8h_source.html">edge_labeler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/home/xuezhisd/CLionProjects/g2o/g2o/apps/g2o_hierarchical/<a class="el" href="edge__labeler_8h_source.html">edge_labeler.h</a></li>
<li>/home/xuezhisd/CLionProjects/g2o/g2o/apps/g2o_hierarchical/<a class="el" href="edge__labeler_8cpp_source.html">edge_labeler.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 18 2019 20:14:46 for g2o by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
